//////////////////////////////////////////////////////////////
// Communication coming to and from the master is managed by the hardware.
// Communication going to and from the following octaves is generated by SoftwareSerial.

// Alternatively, communication could be handled by the hardware, allowing the hardware to handle
// the intensive communication part, while the return to the master, which is simpler, is managed
// by the software.

// All messages end with '\n'.

// General reset: Received from the master: if the message starts with 'R', if it's a communication error,
// everything is reset. For example, if the master sends 'RRRRR', everything is guaranteed to be reset to 0,
// and a response of "R"+octaveNumber+"RR\n" is sent to the master to signal the reset.
// Assignment of the octave number: Received from the master: if the message starts with 'S', the number that
// follows is the current octave number (n), and 'S'+(n+1)+'\n' is transmitted, and 'S'+n+'\n' is sent back
// to the master.
// Request for the state of the keys: Received from the master: preceded by the octave number, followed by 'Q'.
// The response is a message in the form octaveNumber+'T'+state of the keys in hexadecimal in a string.
// Request to turn on a key: Received from the master: preceded by the octave number, followed by 'O' followed by
// the key number and the color code to display ('0' for no color). The response is a message in the form
// octaveNumber+'K'+key number+color code.

//Everything in the code that has to do with the Adafruit servo driver is not beeing used and has been replaced by the neopixel code
//////////////////////////////////////////////////////////////

#include <Wire.h>
#include <MPR121.h>
#include <MPR121_defs.h>

#include <Adafruit_PWMServoDriver.h>

//neopixel
#include <FastLED.h>

#define HARD_SPEED 115200
#define DBG_SPEED 9600
//neopixel
#define LED_PIN     2         // the pin your LED strip is connected to
#define NUM_LEDS    600       // <------------<<<<< change this to the number of LEDs
#define BRIGHTNESS  64        // control the brightness of the LEDs (max = 255)
#define LED_TYPE    WS2812    
#define COLOR_ORDER GRB       
CRGB leds[NUM_LEDS];          

#define UPDATES_PER_SECOND 100

CRGBPalette16 currentPalette;
TBlendType    currentBlending;

extern CRGBPalette16 myRedWhiteBluePalette;
extern const TProgmemPalette16 myRedWhiteBluePalette_p PROGMEM;

//depleted code
Adafruit_PWMServoDriver pwm0 = Adafruit_PWMServoDriver(0x40);
Adafruit_PWMServoDriver pwm1 = Adafruit_PWMServoDriver(0x41);
Adafruit_PWMServoDriver pwm2 = Adafruit_PWMServoDriver(0x42);
//

bool bFirst = true;
bool bInit = false;
bool bInitIt = false;

byte colorKey[ 12 ] = {1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 5, 4}; // std color for the key, can be changed by master
byte touchStatus[ 12 ]; // 0 released - 1 pressed
byte touchColors[ 12 ];

byte tlcColor[ 8 ][ 3 ] =
{
  0, 0, 0,
  9, 0, 0,
  0, 9, 0,
  0, 0, 9,
  9, 9, 0,
  9, 0, 9,
  0, 9, 9,
  9, 9, 9
};

byte tlcIdx[ 12 ][ 3 ] = {
  1, 2, 3,
  4, 5, 6,
  7, 8, 9,
  10, 11, 12,
  17, 18, 19,
  20, 21, 22,
  23, 24, 25,
  26, 27, 28,
  33, 34, 35,
  36, 37, 38,
  39, 40, 41,
  42, 43, 44
};

#define DebugSerial Serial     // 0/1
#define SlaveSerial Serial1    // 19/18
#define MasterSerial Serial2   // 17/16

byte stateReturnPath; // length of messages
byte stateMaster;

char msgFromSlave[ 100 ];  // messages
char msgFromMaster[ 100 ];
char dbgMaster[ 100 ];

char octaveNumber = '-';

// Setup MPR
int touche[ 12 ] = { 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0 };
int toucheup[ 12 ] = { 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0 };
int touchedn[ 12 ] = { 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0 };
int up1 = 12;
int down1 = 11;
int up2 = 23;
int down2 = 22; //22
bool bLast = false;

int zzDbg = 0;
#define _DEBUG_ENABLED

//////////////////////////////////////////////////////////////
void debug( char *txt )
{
#ifdef _DEBUG_ENABLED
  DebugSerial.write( txt );
#endif
}

//////////////////////////////////////////////////////////////
void setup( )
{
  DebugSerial.begin( DBG_SPEED );
  debug( "***** setting up Serials\n" );
  SlaveSerial.begin( HARD_SPEED );
  MasterSerial.begin( HARD_SPEED );

  while ( !SlaveSerial );
  while ( !MasterSerial );

  while ( MasterSerial.available( ) )    messageFromMaster( MasterSerial.read( ) ); // empty queue
  while ( SlaveSerial.available( ) )     messageFromSlave ( SlaveSerial.read( )  ); // empty queue

  bInit = false;
  bInitIt = false;
  bLast = false;
  bFirst = true;
  stateReturnPath = 0;
  stateMaster = 0;

  //////////////////////////////////
  debug( "***** Set I2C clock\n" );
  Wire.setClock(400000);

  debug( "***** setup PCAs\n" );
  pwm0.begin();
  pwm1.begin();
  pwm2.begin();

  debug("***** setup Neopixels\n");
  //neopixel
  FastLED.addLeds<LED_TYPE, LED_PIN, COLOR_ORDER>(leds, NUM_LEDS).setCorrection( TypicalLEDStrip );
  FastLED.setBrightness(  BRIGHTNESS );
            //neopixel
  for (int i=0; i<NUM_LEDS; i=i+1) {
  leds[i] = CRGB::Black;
}
    
    FastLED.show();
    FastLED.delay(1000 / UPDATES_PER_SECOND);


  debug( "***** set freq PCAs\n" );
  pwm0.setPWMFreq(1600);
  pwm1.setPWMFreq(1600);
  pwm2.setPWMFreq(1600);

  debug( "***** set led off\n" );
  for ( int i = 0; i < 16; i++ )
  {
    pwm0.setPWM(i, 0, 0 );
    pwm1.setPWM(i, 0, 0 );
    pwm2.setPWM(i, 0, 0 );
  }

  ////////////////////////////////////
  debug( "***** setting up MPR121\n" );
  if ( !MPR121.begin( 0x5A ) )
  {
    debug( "error setting up MPR121\n" );
    switch ( MPR121.getError( ) )
    {
      case NO_ERROR:
        debug( "no error\n" );
        break;
      case ADDRESS_UNKNOWN:
        debug( "incorrect address\n" );
        break;
      case READBACK_FAIL:
        debug( "readback failure\n" );
        break;
      case OVERCURRENT_FLAG:
        debug( "overcurrent on REXT pin\n" );
        break;
      case OUT_OF_RANGE:
        debug( "electrode out of range\n" );
        break;
      case NOT_INITED:
        debug( "not initialised\n" );
        break;
      default:
        debug( "unknown error\n" );
        break;
    }
    while ( 1 ); // loop until reset
  }

  MPR121.setInterruptPin( 2 );
  MPR121.setTouchThreshold( up2 ); // default 40 = touch
  MPR121.setReleaseThreshold( down2 );  // default 20 = touch
  for ( int i = 0; i < 12; i++ )
  {
    int up = up1;
    int down = down1;
    if ( touche[ i ] == 1 )
    {
      up = up2;
      down = down2;
    }
    MPR121.setTouchThreshold( i, down ); // default 40 = touch
    MPR121.setReleaseThreshold( i, up );  // default 20 = touch
  }

  ////////////////////////////////////////
  delay(100);
  debug( "***** End Setup\n" );
}

//////////////////////////////////////////////////////////////
void LedPWMUpdate( )
{
  for ( int i = 0; i < 4; i++ )
  {
    pwm0.setPWM(i * 3 + 2, 0, 455 * tlcColor[ touchColors[ i + 0 ] ][ 0 ] );
    pwm0.setPWM(i * 3 + 3, 0, 455 * tlcColor[ touchColors[ i + 0 ] ][ 1 ] );
    pwm0.setPWM(i * 3 + 4, 0, 455 * tlcColor[ touchColors[ i + 0 ] ][ 2 ] );
    pwm1.setPWM(i * 3 + 2, 0, 455 * tlcColor[ touchColors[ i + 4 ] ][ 0 ] );
    pwm1.setPWM(i * 3 + 3, 0, 455 * tlcColor[ touchColors[ i + 4 ] ][ 1 ] );
    pwm1.setPWM(i * 3 + 4, 0, 455 * tlcColor[ touchColors[ i + 4 ] ][ 2 ] );
    pwm2.setPWM(i * 3 + 2, 0, 455 * tlcColor[ touchColors[ i + 8 ] ][ 0 ] );
    pwm2.setPWM(i * 3 + 3, 0, 455 * tlcColor[ touchColors[ i + 8 ] ][ 1 ] );
    pwm2.setPWM(i * 3 + 4, 0, 455 * tlcColor[ touchColors[ i + 8 ] ][ 2 ] );
  }
}

//////////////////////////////////////////////////////////////
int waitFeedback( int valDelay )
{
  stateReturnPath = 0;
  msgFromSlave[ stateReturnPath ] = 0;

  int i = 0;
  bool bStop = false;
  // wait for return
  while ( !bStop )
  {
    delay( 1 );
    i++;
    if ( i > valDelay ) bStop = true;
    if ( !bStop )
    {
      while ( SlaveSerial.available( ) )
      {
        char c = SlaveSerial.read();
        messageFromSlave( c );
        if ( c == '\n' )
          return 1;
      }
    }
  }

  debug( "***** wait failed\n" );
  return 0;
}

//////////////////////////////////////////////////////////////
void resetPiano( )
{
  bInit = false;
  bInitIt = false;
  bLast = false;

  stateReturnPath = 0;
  stateMaster = 0;

  SlaveSerial.write( "R\n" );
  debug( "-->R\n" );

  /*waitFeedback( 500 ) ;
  MasterSerial.write( "R\n" );
  debug( "==>R\n" );*/
}

//////////////////////////////////////////////////////////////
void askForReset( )
{
  MasterSerial.write( "uuuuu\n" );
  debug( "==>uuuuu\n" );
  stateReturnPath = 0;
  stateMaster = 0;

}

//////////////////////////////////////////////////////////////
void notifyKeyChanged( char touchId, char state )
{
  char msg[30];
  msg[ 0 ] = 'n';
  msg[ 1 ] = octaveNumber + 0x30;
  msg[ 2 ] = touchId + 0x30;
  msg[ 3 ] = state + 0x30;
  msg[ 4 ] = '\n';
  msg[ 5 ] = 0;
    if(state==1){
  FastLED.addLeds<LED_TYPE, LED_PIN, COLOR_ORDER>(leds, NUM_LEDS).setCorrection( TypicalLEDStrip );
  FastLED.setBrightness(  BRIGHTNESS );
    //neopixel
    //ungefähr 27leds für die schwarzen Tasten
    //ungefähr 60leds für die weißen Tasten
    
    //Taste 1 Rot
      if (touchId == 0) {
    for(int i=0; i<61; i=i+1){
    leds[i] = CRGB::Red;
    }
}

//Taste 2 Grün
else if (touchId == 1) {
    for(int i=61; i<89; i=i+1){
    leds[i] = CRGB::Green;
    }
}

//Taste 3 Blau
else if (touchId == 2) {
    for(int i=89; i<149; i=i+1){
    leds[i] = CRGB::Blue;
    }
}
//Taste 4 Lila
else if (touchId == 3) {
    for(int i=149; i<177; i=i+1){
    leds[i] = CRGB::Purple;
    }
}
//Taste 5 Grau
else if (touchId == 4) {
    for(int i=177; i<238; i=i+1){
    leds[i] = CRGB::Grey;
    }
}
//Taste 6 Gelb
else if (touchId == 5) {
    for(int i=238; i<300; i=i+1){
    leds[i] = CRGB::Yellow;
    }
}
//Taste 7 Orange
else if (touchId == 6) {
    for(int i=300; i<327; i=i+1){
    leds[i] = CRGB::Orange;
    }
}
//Taste 8 Aqua
else if (touchId == 7) {
    for(int i=327; i<388; i=i+1){
    leds[i] = CRGB::Aqua;
    }
}
//Taste 9 Pink
else if (touchId == 8) {
    for(int i=388; i<416; i=i+1){
    leds[i] = CRGB::Pink;
    }
}
//Tatse 10 Orange
else if (touchId == 9) {
    for(int i=416; i<477; i=i+1){
    leds[i] = CRGB::Orange;
    }
}
//Tatse 11 Gelb
else if (touchId == 10) {
    for(int i=477; i<505; i=i+1){
    leds[i] = CRGB::Yellow;
    }
}
//Tatse 12 Grün
else if (touchId == 11) {
    for(int i=505; i<566; i=i+1){
    leds[i] = CRGB::Green;
    }
}
FastLED.show();  
  }

 else if(state==2){
 FastLED.addLeds<LED_TYPE, LED_PIN, COLOR_ORDER>(leds, NUM_LEDS).setCorrection( TypicalLEDStrip );
  FastLED.setBrightness(  BRIGHTNESS );
            //neopixel resets for the keys when released
       if (touchId == 0) {
    for(int i=0; i<61; i=i+1){
    leds[i] = CRGB::Black;
    }
}
else if (touchId == 1) {
    for(int i=61; i<89; i=i+1){
    leds[i] = CRGB::Black;
    }
}

else if (touchId == 2) {
    for(int i=89; i<149; i=i+1){
    leds[i] = CRGB::Black;
    }
}
else if (touchId == 3) {
    for(int i=149; i<177; i=i+1){
    leds[i] = CRGB::Black;
    }
}
else if (touchId == 4) {
    for(int i=177; i<238; i=i+1){
    leds[i] = CRGB::Black;
    }
}
else if (touchId == 5) {
    for(int i=238; i<300; i=i+1){
    leds[i] = CRGB::Black;
    }
}
else if (touchId == 6) {
    for(int i=300; i<327; i=i+1){
    leds[i] = CRGB::Black;
    }
}
else if (touchId == 7) {
    for(int i=327; i<388; i=i+1){
    leds[i] = CRGB::Black;
    }
}
else if (touchId == 8) {
    for(int i=388; i<416; i=i+1){
    leds[i] = CRGB::Black;
    }
}
else if (touchId == 9) {
    for(int i=416; i<477; i=i+1){
    leds[i] = CRGB::Black;
    }
}
else if (touchId == 10) {
    for(int i=477; i<505; i=i+1){
    leds[i] = CRGB::Black;
    }
}
else if (touchId == 11) {
  
    for(int i=505; i<566; i=i+1){
    leds[i] = CRGB::Black;
    }
}
FastLED.show();  
  }
  MasterSerial.write( msg );
  debug( "==>" );
  debug( msg );
}

//////////////////////////////////////////////////////////////
void ledOnOff( char id, char color )
{
  if ( id > 11 )
  {
    for ( id = 0; id < 12; id++ )
    {
      touchColors[ id ] = color;
    }
  }
  else
  {
    touchColors[ id ] = color;
  }

  LedPWMUpdate( );
}

//////////////////////////////////////////////////////////////
void messageFromSlave( char newIn )
{
  if ( !bInitIt ) return;
  if ( newIn == '$' ) newIn = '\n';
  msgFromSlave[ stateReturnPath++ ] = newIn;
  msgFromSlave[ stateReturnPath ] = 0;
  if ( newIn == '\n' )
  { // end of message
    //if ( msgFromSlave[0] != 'R' )
    {
      debug( "<--" );
      debug(msgFromSlave);
      debug( "==>" );
      debug(msgFromSlave);
      MasterSerial.write( msgFromSlave );
    }
    stateReturnPath = 0;
  }
}


//////////////////////////////////////////////////////////////
void messageFromMaster( char newIn )
{
  if ( newIn == '$' ) newIn = '\n';

  msgFromMaster[ stateMaster++ ] = newIn;
  msgFromMaster[ stateMaster ] = 0;

  if ( newIn == '\n' )
  { // end of message

    if ( bInit == true )
    {
      debug( "<==" );
      debug( msgFromMaster );
    }
    else
    {
      debug( "<==" );
      debug( "D" );
      debug( msgFromMaster );
    }
    switch ( msgFromMaster[ 0 ] )
    { 
      case 'O':
        if ( bInit == true )
        {
          if ( msgFromMaster[ 1 ] != octaveNumber + 0x30 )
          {
            SlaveSerial.write( msgFromMaster, stateMaster ); //not talking to me: bypass
            debug( "pass-->" );
            debug( msgFromMaster );
          }
          else
          {
            ledOnOff( msgFromMaster[ 2 ] - 0x30, msgFromMaster[ 3 ] - 0x30 );
          }
        }
        break;
      case 'P':
        if ( bInit == true )
        {
          if ( msgFromMaster[ 1 ] != octaveNumber + 0x30 )
          {
            SlaveSerial.write( msgFromMaster ); //not talking to me: bypass
            debug( "pass-->" );
            debug( msgFromMaster );
          }
          else
          {
            colorKey[ msgFromMaster[ 2 ] - 0x30 ] = msgFromMaster[ 3 ] - 0x30;
            msgFromMaster[ 0 ] = 'p';
            debug( "==>" );
            debug( msgFromMaster );
            MasterSerial.write( msgFromMaster );
          }
        }
        break;
      case 'R': // Reset all
        resetPiano( );
        break;
      case 'S': // set octave number
        {
          if ( bInitIt == true )
          {
            debug( "pass-->" ); //not talking to me: bypass
            debug( msgFromMaster );
            SlaveSerial.write( msgFromMaster ); //not talking to me: bypass
              if ( msgFromMaster[ 1 ] == 'd' )
              {
                bInit = true;
                if ( msgFromMaster[ 1 ] == octaveNumber )
                {
                  bLast = true;
                }
            }
          }
          else
          {
            octaveNumber = msgFromMaster[ 1 ] - 0x30;
            msgFromMaster[ 0 ] = 's';
            debug( "==>" );
            debug( msgFromMaster );
            MasterSerial.write( msgFromMaster );
            bInitIt = true;
            debug("init done\n" );
          }
        }
        break;

      default:
        debug( "never come here\n" );
        MasterSerial.write( msgFromMaster );
        debug( msgFromMaster );
        break;
    }
    msgFromMaster[ 0 ] = 0;
    stateMaster = 0;
  }
}

//////////////////////////////////////////////////////////////
void loop( )
{
  ////////////////////////Nachträglich
   MPR121.updateAll( );
    for ( int i = 0; i < 12; i++ )
    {
      if ( MPR121.isNewTouch( i ) )
      {
        Serial.print(i); 
        Serial.println(" touched");
        notifyKeyChanged( i, 1 );
        touchStatus[ i ] = 1;
        touchColors[ i ] = colorKey[ i ];
        LedPWMUpdate( );
      }
      else if ( MPR121.isNewRelease( i ) )
      {
        Serial.print(i); 
        Serial.println(" released");
        notifyKeyChanged( i, 2 );
        touchStatus[ i ] = 0;
        touchColors[ i ] = 0;
        LedPWMUpdate( );
      }
    }
    //////////////////////////
  if ( bFirst )
  {
    ledOnOff( 12, 0 );
    bFirst = false;
  }

  if ( bInit == true )
  {
    MPR121.updateAll( );
    for ( int i = 0; i < 12; i++ )
    {
      if ( MPR121.isNewTouch( i ) )
      {
        Serial.print(i); 
        Serial.println(" touched");
        notifyKeyChanged( i, 1 );
        touchStatus[ i ] = 1;
        touchColors[ i ] = colorKey[ i ];
        LedPWMUpdate( );
      }
      else if ( MPR121.isNewRelease( i ) )
      {
        Serial.print(i); 
        Serial.println(" released");
        notifyKeyChanged( i, 2 );
        touchStatus[ i ] = 0;
        touchColors[ i ] = 0;
        LedPWMUpdate( );
      }
    }
  }
  else
  {
    for ( int i = 0; i < 12; i++ )
    {
      touchColors[ i ] = 0;
      touchStatus[ i ] = 0;
    }
  }

  if ( MasterSerial.available( ) )
  {
    messageFromMaster( MasterSerial.read( ) );
  }

  if ( bLast )
  {
    while ( SlaveSerial.available( ) ) SlaveSerial.read( ) ;
  }
  else
  {
    if ( SlaveSerial.available( ) )
    {
      messageFromSlave( SlaveSerial.read( ) );
    }
  }
}
